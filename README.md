# bin1.exe
<img width="1098" height="647" alt="image" src="https://github.com/user-attachments/assets/fadb2392-2557-422e-8ee1-a244b0e0da38" />

### -Открыл Ida, закинул туда bin1.exe. 
### -После декомпиляции получил код:
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char Str1[128]; // [rsp+20h] [rbp-80h] BYREF

  _main(argc, argv, envp);
  puts("Hello, enter password ");
  scanf("%s", Str1);
  if ( !strcmp(Str1, "arctf{z3r0_0r_no7_0}") )
    puts("Yes!");
  else
    puts("Wrong!");
  system("Pause");
  return 0;
}
```
### Сначала вписаваем строку

### -Потом видим, что наша строка сравнивается с arctf{z3r0_0r_no7_0}, если строки равны, он написат Yes!, а если не равны, то напишет Wrong!
```c
if ( !strcmp(Str1, "arctf{z3r0_0r_no7_0}") )
```

# bin2.exe
<img width="1098" height="684" alt="image" src="https://github.com/user-attachments/assets/afcb22ed-327d-44af-a828-434b549161b3" />


### -Открыл Ida, закинул туда bin2.exe.
### -После декомпиляции получил код:

```c
int sub_401000()
{
  char Str[256]; // [esp+0h] [ebp-100h] BYREF

  printf("Enter flag to check: ");
  scanf("%s", Str);
  if ( strlen(Str) == 12 )
  {
    if ( strcmp(Str, Str2) > 0 )
    {
      if ( strcmp(Str, aMiccheckH4y) < 0 )
        printf("Yes! Correct flag is %s\n", Str);
      else
        printf("Wrong check 2!\n");
      return 0;
    }
    else
    {
      printf("Wrong check 1!\n");
      return 0;
    }
  }
  else
  {
    printf("Wrong length!\n");
    return 0;
  }
}
```

### -Просмотрел код, увидел, что необходимо ввести какой-то пароль, который в длину должен быть 12 букв
### -Начал искать дальше, увидел 2 пароля, проверил их, понял, что в них последнии буквы находятся в алфавитном порядке, но пропущен x.
### -Посмотрел, что сравнивает программа в if и заметил, что сравнивает с двумя паролями и необходимо написать такой, который будет между ними
### -Написал, проверил, все работает.

# bin3.exe
<img width="1097" height="684" alt="image" src="https://github.com/user-attachments/assets/8d45f26b-4d33-4e68-bbbd-b65d27002a8e" />

### -Открыл Ida, закинул туда bin2.exe.
### -Просмотрел код
### -Длина строки 17, первые 3 цифры это 333
### atoi(Str) == 333
### -Дальше программа проверяет по функции и проверяет какие буквы стоят
### -На 5 и 7 и 11 должна находится буква o
### (( sub_401000((int)Str, 11) == 111)
### -Дальше на 9 должна быть цифра 0
### sub_401000((int)Str, 9) == 48
### -Дальше на 16 должна быть буква g
### sub_401000((int)Str, 16) == 103
### -Потом 13, 15 и 17 должен быть такой же символ, как у 9, тоесть 0
### -На 6,8,10,12,14,16 должен быть такой же символ, как у 4, тоесть g
### Получаем такую комбинацию:
### 333gogog0gog0g0g0

# bin4.exe
<img width="1094" height="638" alt="image" src="https://github.com/user-attachments/assets/ff789723-58a6-4ee1-8ba1-df0cee65f0b0" />

### -Открыл Ida, закинул туда bin2.exe.
### -Заметил, что первая проверка означает, что берется длина строки, умножается на 4 и сравнивается с айди первого символа, если первая буква H, то всего длина должна быть 18
### -Дальше функция проверяет на одинаковые символы
### !strncmp(Str, Str2, 8u)
### В нашем случае надо, чтобы 8 первых символов совпадали с str2
### Нашел саму строку str2: 4_points.
### Первый символ говорит о том, что в строке должно быть 52/4, тоесть 13 символов
### Дальше идет вторая проверка
### !strcmp(Str1, aKomne)
### Она проверяет нашу строку с еще одной строкой(komne), попробовал сделать следующим образом: посчитал количество символов в 4_points и komne и пришел к выводу, что надо просто соединить 2 строки и напить ее

# bin5.exe
<img width="1096" height="649" alt="image" src="https://github.com/user-attachments/assets/c5cf9149-3285-4fe5-a9b2-f6f09a3ada70" />

### -Открыл Ida, закинул туда bin5.exe.
### -Заметил, что идет проверка в цикле и проверяется схожесть айди символов.
### -Изучив подробнее код стало ясно, что str это f2hwldozg|:wbq, дальше в цикле можно увидеть i + v3[i] != Str[i], что означает, что правильные символы можно найти следующим образом:
### -Надо сначала заменить ! на =  i + v3[i] == Str[i], поменять местами: v3[i] == Str[i] – i, открыв айди символов, перебираем каждый:
### f-0 = f
### 2-1=1 и так далее берем айди и вычитаем саму i, получая нужные буквы

