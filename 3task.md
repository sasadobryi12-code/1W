### Открыл IDA, закинул бинарник и получил код:
```c
__int64 start()
{
  __int64 v0; // rcx
  __int64 i; // rdx
  __int16 v2; // ax
  __int64 v3; // rcx
  __int64 j; // r10
  __int64 v5; // rax
  __int16 v6; // t2
  __int64 result; // rax
  char v8[16]; // [rsp+0h] [rbp-10h]

  v0 = 0i64;
  for ( i = 0i64; ; ++i )
  {
    v2 = *(_WORD *)((char *)&unk_140003000 + v0);
    v0 += 2i64;
    if ( !v2 )
      break;
  }
  v3 = 0i64;
  for ( j = 0i64; ; ++j )
  {
    v5 = *(_WORD *)((char *)&unk_140003000 + v3) >> 1;
    v6 = (unsigned __int16)v5 % 6u;
    LOBYTE(v5) = (unsigned __int16)v5 / 6u;
    BYTE1(v5) = v6;
    result = v5 - 1;
    v8[j] = result;
    if ( i == j )
      break;
    v3 += 2i64;
  }
  v8[j] = 0;
  return result;
}
```

### Данный бинарник ничего не пишет в консоль и не просит ничего ввести
### В коде присутствует скрытая строка, которая извлекается из бинарных данных
### В динарнике находится 2 цикла
```c
  for ( i = 0i64; ; ++i )
  {
    v2 = *(_WORD *)((char *)&unk_140003000 + v0);
    v0 += 2i64;
    if ( !v2 )
      break;
  }
```
### Первый цикл вычисляет длину, проходит и выходит из цикла, если v2 == 0
#### ----------------------------------------------------
#### v0 = 0: читаем unk_140003000[0] → v2 = значение_1
#### v0 += 2 → v0 = 2
#### проверка: if (!v2) → если не 0, продолжаем
#### i++ → i = 1
#### ----------------------------------------------------
#### v0 = 2: читаем unk_140003000[1] → v2 = значение_2  
#### v0 += 2 → v0 = 4
#### проверка: if (!v2) → если не 0, продолжаем
#### i++ → i = 2
#### ----------------------------------------------------
#### v0 = 2*(N-1): читаем unk_140003000[N-1] → v2 = 0
#### ВЫХОД ИЗ ЦИКЛА по break
#### ----------------------------------------------------

### Дальше идёт второй цикл
```c
  for ( j = 0i64; ; ++j )
  {
    v5 = *(_WORD *)((char *)&unk_140003000 + v3) >> 1;
    v6 = (unsigned __int16)v5 % 6u;
    LOBYTE(v5) = (unsigned __int16)v5 / 6u;
    BYTE1(v5) = v6;
    result = v5 - 1;
    v8[j] = result;
    if ( i == j )
      break;
    v3 += 2i64;
  }
```

### Сдвигает вправо на 1 бит
```c
v5 = unk_140003000[v3] >> 1;
```

### Делит на 6: частное -> младший байт, остаток -> старший байт

```c
v6 = (unsigned __int16)v5 % 6u;
LOBYTE(v5) = (unsigned __int16)v5 / 6u;
YTE1(v5) = v6;
```










































